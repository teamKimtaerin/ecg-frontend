## 작성 요구사항
다음 형식으로 한글 PR 설명을 작성해주세요:

### PR 제목
[타입] 간단한 설명 (예: [Feat] 블로그 생성 기능 구현)

### PR 본문
## 개요
- 무엇을 수정했는지
- 왜 수정했는지  
- 핵심 변경사항 요약

## 설명

### What (무엇을 수정했나요?)
구체적으로 어떤 기능이 추가/수정/삭제되었는지 설명

### Why (왜 수정했나요?)
이 변경이 필요했던 이유, 해결하려던 문제점

### How (어떻게 수정했나요?)
기술적인 구현 방법, 사용한 기술, 아키텍처 변경사항

## 📋 체크리스트
- [ ] 기능 테스트 완료
- [ ] 코드 리뷰 준비 완료
- [ ] 문서 업데이트 (필요시)

## 🔍 리뷰 포인트
리뷰어가 특별히 확인해야 할 부분

---
🤖 Generated with Claude Code

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
다음 Git 변경사항을 분석해서 위 요구사항에 따라 한글로 상세한 PR 설명을 작성해주세요.

## 작업 요약
Feat: 트랜스크립션 진행 상태 및 저장소 개선

## 변경 통계
- 변경된 파일: .claude/settings.local.json,src/app/(main)/demo/page.tsx,src/app/(route)/editor/page.tsx,src/app/(route)/editor/types/index.ts,src/app/layout.tsx
- 추가: +1444 lines
- 삭제: -133 lines

## 변경사항 Diff
```diff
diff --git a/.claude/settings.local.json b/.claude/settings.local.json
index 391db44..ba90d98 100644
--- a/.claude/settings.local.json
+++ b/.claude/settings.local.json
@@ -17,11 +17,17 @@
       "Bash(yarn dev)",
       "Bash(jobs)",
       "Read(//Users/ahntaeju/Desktop/Screenshots/**)",
-      "Bash(npm install:*)"
+      "Bash(npm install:*)",
+      "Bash(npm run lint)",
+      "Bash(npm run lint:*)",
+      "Bash(git fetch:*)",
+      "Bash(git checkout:*)"
     ],
     "deny": [],
     "ask": []
   },
   "enableAllProjectMcpServers": true,
-  "enabledMcpjsonServers": ["shadcn-ui"]
-}
+  "enabledMcpjsonServers": [
+    "shadcn-ui"
+  ]
+}
\ No newline at end of file
diff --git a/src/app/(main)/demo/page.tsx b/src/app/(main)/demo/page.tsx
index 735bae7..9347711 100644
--- a/src/app/(main)/demo/page.tsx
+++ b/src/app/(main)/demo/page.tsx
@@ -12,7 +12,7 @@ export default function Home() {
   const [lastScrollY, setLastScrollY] = useState(0)
   const [isTranscriptionModalOpen, setIsTranscriptionModalOpen] =
     useState(false)
-  const { isTranscriptionLoading, handleFileSelect, handleStartTranscription } =
+  const { handleFileSelect, handleStartTranscription } =
     useUploadModal()
 
   const heroRef = useRef<HTMLElement>(null)
@@ -129,15 +129,13 @@ export default function Home() {
       {/* Upload Modal */}
       <UploadModal
         isOpen={isTranscriptionModalOpen}
-        onClose={() =>
-          !isTranscriptionLoading && setIsTranscriptionModalOpen(false)
-        }
+        onClose={() => setIsTranscriptionModalOpen(false)}
         onFileSelect={handleFileSelect}
         onStartTranscription={wrappedHandleStartTranscription}
         acceptedTypes={['audio/*', 'video/*']}
         maxFileSize={FILE_SIZE_LIMITS.large} // 100MB
         multiple={true}
-        isLoading={isTranscriptionLoading}
+        isLoading={false}
       />
     </div>
   )
diff --git a/src/app/(route)/editor/page.tsx b/src/app/(route)/editor/page.tsx
index a91d0cb..2785281 100644
--- a/src/app/(route)/editor/page.tsx
+++ b/src/app/(route)/editor/page.tsx
@@ -5,6 +5,7 @@ import { useCallback, useEffect, useId, useState } from 'react'
 
 // Store
 import { useEditorStore } from './store'
+import { useTranscriptionStore } from '@/lib/store/transcriptionStore'
 
 // Storage & Managers
 import { mediaStorage } from '@/utils/storage/mediaStorage'
@@ -26,6 +27,7 @@ import { useUploadModal } from '@/hooks/useUploadModal'
 import { useDragAndDrop } from './hooks/useDragAndDrop'
 import { useSelectionBox } from './hooks/useSelectionBox'
 import { useUnsavedChanges } from './hooks/useUnsavedChanges'
+import { useTranscriptionPolling } from '@/hooks/useTranscriptionPolling'
 
 // Components
 import SelectionBox from '@/components/DragDrop/SelectionBox'
@@ -43,6 +45,7 @@ import SpeakerManagementSidebar from './components/SpeakerManagementSidebar'
 // Utils
 import { EditorHistory } from '@/utils/editor/EditorHistory'
 import { areClipsConsecutive } from '@/utils/editor/clipMerger'
+import { convertSegmentsToClips, extractSpeakersFromSegments } from '@/utils/transcription/segmentConverter'
 import { MergeClipsCommand } from '@/utils/editor/commands/MergeClipsCommand'
 import { SplitClipCommand } from '@/utils/editor/commands/SplitClipCommand'
 import { DeleteClipCommand } from '@/utils/editor/commands/DeleteClipCommand'
@@ -109,6 +112,12 @@ export default function EditorPage() {
   // Track unsaved changes
   useUnsavedChanges(hasUnsavedChanges)
 
+  // Initialize transcription polling
+  useTranscriptionPolling()
+
+  // Get transcription store for completion handling
+  const { onComplete } = useTranscriptionStore()
+
   // Session recovery and initialization
   useEffect(() => {
     const initializeEditor = async () => {
@@ -304,7 +313,7 @@ export default function EditorPage() {
   const dndContextId = useId()
 
   // Upload modal hook
-  const { isTranscriptionLoading, handleFileSelect } = useUploadModal()
+  const { handleFileSelect, handleStartTranscription } = useUploadModal()
 
   // DnD functionality
   const {
@@ -532,11 +541,137 @@ export default function EditorPage() {
     }
   }
 
-  // Upload modal handler - currently not used, placeholder for future implementation
-  const wrappedHandleStartTranscription = async () => {
-    // TODO: Implement actual file upload and transcription logic
-    setIsUploadModalOpen(false)
-    showToast('파일 업로드 기능은 준비 중입니다')
+  // Set up transcription completion handler
+  useEffect(() => {
+    log('EditorPage.tsx', 'Setting up transcription completion handler')
+    
+    onComplete((results: unknown) => {
+      log('EditorPage.tsx', 'Transcription completion callback triggered')
+      
+      try {
+        // Type guard function to check if segments are valid
+        const isValidSegmentArray = (segments: unknown): segments is Array<{
+          start_time: number
+          end_time: number
+          speaker: { speaker_id: string }
+          text: string
+          words: Array<{
+            word: string
+            start: number
+            end: number
+            volume_db?: number
+            pitch_hz?: number
+          }>
+        }> => {
+          return Array.isArray(segments) && segments.length > 0 &&
+            segments.every(segment => 
+              segment && 
+              typeof segment === 'object' && 
+              'start_time' in segment && 
+              'end_time' in segment &&
+              'speaker' in segment &&
+              'text' in segment
+            )
+        }
+
+        // Type guard to check if results has the expected structure
+        if (results && typeof results === 'object' && 'result' in results) {
+          const mlResult = results as { result: { segments: unknown } }
+          
+          if (mlResult.result?.segments && isValidSegmentArray(mlResult.result.segments)) {
+            log('EditorPage.tsx', `Processing ${mlResult.result.segments.length} segments`)
+            
+            // Convert ML server segments to clips
+            const newClips = convertSegmentsToClips(mlResult.result.segments)
+            log('EditorPage.tsx', `Converted to ${newClips.length} clips`)
+            
+            // Extract speakers from segments
+            const newSpeakers = extractSpeakersFromSegments(mlResult.result.segments)
+            log('EditorPage.tsx', `Extracted ${newSpeakers.length} speakers: ${newSpeakers.join(', ')}`)
+            
+            // Update editor with new clips and speakers
+            setClips(newClips)
+            setSpeakers(newSpeakers)
+            
+            // Show success message
+            showToast(`${newClips.length}개의 자막이 생성되었습니다!`, 'success')
+            log('EditorPage.tsx', 'Clips and speakers updated successfully')
+          } else {
+            log('EditorPage.tsx', 'Invalid segments structure in results')
+            console.warn('Invalid segments structure in transcription results', results)
+            showToast('자막 생성에 실패했습니다. 결과 구조가 올바르지 않습니다.', 'error')
+          }
+        } else if (results && typeof results === 'object' && 'segments' in results) {
+          // Handle direct segments array (legacy format)
+          const legacyResult = results as { segments: unknown }
+          
+          if (legacyResult.segments && isValidSegmentArray(legacyResult.segments)) {
+            log('EditorPage.tsx', `Processing legacy format with ${legacyResult.segments.length} segments`)
+            
+            const newClips = convertSegmentsToClips(legacyResult.segments)
+            const newSpeakers = extractSpeakersFromSegments(legacyResult.segments)
+            
+            setClips(newClips)
+            setSpeakers(newSpeakers)
+            
+            showToast(`${newClips.length}개의 자막이 생성되었습니다!`, 'success')
+            log('EditorPage.tsx', 'Legacy format clips and speakers updated successfully')
+          }
+        } else {
+          log('EditorPage.tsx', 'Unrecognized results structure')
+          console.warn('Unrecognized transcription results structure:', results)
+          showToast('자막 생성에 실패했습니다. 결과 형식을 인식할 수 없습니다.', 'error')
+        }
+      } catch (error) {
+        log('EditorPage.tsx', `Error processing transcription results: ${error}`)
+        console.error('Error processing transcription results:', error)
+        showToast('자막 처리 중 오류가 발생했습니다.', 'error')
+      }
+    })
+  }, [onComplete, setClips, setSpeakers])
+
+  // Upload modal handler - integrates with transcription store
+  const wrappedHandleStartTranscription = async (data: {
+    files: File[]
+    settings: { language: string }
+  }) => {
+    console.log('🚀 wrappedHandleStartTranscription called with:', data)
+    log('EditorPage.tsx', `wrappedHandleStartTranscription called with ${data.files.length} files`)
+    
+    try {
+      // Close upload modal immediately
+      setIsUploadModalOpen(false)
+      log('EditorPage.tsx', 'Upload modal closed')
+      
+      // Convert files and settings to the format expected by handleStartTranscription
+      const transcriptionData = {
+        files: data.files,
+        language: data.settings.language,
+        useDictionary: false,
+        autoSubmit: true,
+        method: 'file' as const,
+      }
+      log('EditorPage.tsx', `Transcription data prepared: ${JSON.stringify({ language: transcriptionData.language, method: transcriptionData.method })}`)
+      
+      // Convert File[] to FileList
+      const dataTransfer = new DataTransfer()
+      data.files.forEach(file => dataTransfer.items.add(file))
+      log('EditorPage.tsx', 'Files converted to FileList')
+      
+      log('EditorPage.tsx', 'About to call handleStartTranscription...')
+      await handleStartTranscription(
+        { ...transcriptionData, files: dataTransfer.files },
+        undefined, // No success callback needed (modal already closed)
+        false // Don't redirect to editor (we're already on editor page)
+      )
+      log('EditorPage.tsx', 'handleStartTranscription completed successfully')
+    } catch (error) {
+      console.error('Failed to start transcription:', error)
+      log('EditorPage.tsx', `wrappedHandleStartTranscription error: ${error}`)
+      showToast('파일 업로드에 실패했습니다')
+      // Reopen modal on error
+      setIsUploadModalOpen(true)
+    }
   }
 
   // Merge clips handler
@@ -1255,7 +1390,7 @@ export default function EditorPage() {
 
         <NewUploadModal
           isOpen={isUploadModalOpen}
-          onClose={() => !isTranscriptionLoading && setIsUploadModalOpen(false)}
+          onClose={() => setIsUploadModalOpen(false)}
           onFileSelect={(files: File[]) => {
             // Convert File[] to FileList for compatibility
             const fileList = new DataTransfer()
@@ -1266,7 +1401,6 @@ export default function EditorPage() {
           acceptedTypes={['audio/*', 'video/*']}
           maxFileSize={100 * 1024 * 1024} // 100MB
           multiple={true}
-          isLoading={isTranscriptionLoading}
         />
 
         <TutorialModal
diff --git a/src/app/(route)/editor/types/index.ts b/src/app/(route)/editor/types/index.ts
index 11cc54e..f097716 100644
--- a/src/app/(route)/editor/types/index.ts
+++ b/src/app/(route)/editor/types/index.ts
@@ -7,6 +7,9 @@ export interface Word {
   isEditable: boolean
   confidence?: number
   appliedAssets?: string[]
+  // Audio metadata from ML server (for animations)
+  volume_db?: number  // Volume level in decibels (-60 to 0)
+  pitch_hz?: number   // Pitch frequency in Hz (50 to 500)
 }
 
 export interface ClipItem {
diff --git a/src/app/layout.tsx b/src/app/layout.tsx
index 31aa739..86c24c5 100644
--- a/src/app/layout.tsx
+++ b/src/app/layout.tsx
@@ -1,6 +1,7 @@
 import type { Metadata } from 'next'
 import { Geist, Geist_Mono, Inter } from 'next/font/google'
 import './globals.css'
+import { TranscriptionProvider } from '@/components/providers/TranscriptionProvider'
 
 const inter = Inter({
   variable: '--font-inter',
@@ -39,7 +40,9 @@ export default function RootLayout({
       <body
         className={`${inter.variable} ${geistSans.variable} ${geistMono.variable} antialiased`}
       >
-        {children}
+        <TranscriptionProvider>
+          {children}
+        </TranscriptionProvider>
       </body>
     </html>
   )
diff --git a/src/components/TranscriptionProgressModal.tsx b/src/components/TranscriptionProgressModal.tsx
new file mode 100644
index 0000000..3519ec7
--- /dev/null
+++ b/src/components/TranscriptionProgressModal.tsx
@@ -0,0 +1,202 @@
+'use client'
+
+import React, { useEffect, useState } from 'react'
+import { createPortal } from 'react-dom'
+import { useTranscriptionStore } from '@/lib/store/transcriptionStore'
+import { useTranscriptionPolling } from '@/hooks/useTranscriptionPolling'
+import ProgressBar from '@/components/ui/ProgressBar'
+import { ChevronRightIcon } from '@/components/icons'
+import { cn } from '@/utils'
+import Image from 'next/image'
+
+const TranscriptionProgressModal: React.FC = () => {
+  const [isMounted, setIsMounted] = useState(false)
+  const {
+    jobId,
+    isModalOpen,
+    isCollapsed,
+    progress,
+    status,
+    videoMetadata,
+    analysisTimeUsed,
+    error,
+    toggleCollapse,
+    closeModal,
+  } = useTranscriptionStore()
+  
+  // Start polling when modal opens
+  useTranscriptionPolling()
+  
+  // Format duration from seconds to mm:ss
+  const formatDuration = (seconds: number): string => {
+    const minutes = Math.floor(seconds / 60)
+    const remainingSeconds = Math.floor(seconds % 60)
+    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`
+  }
+  
+  // Format analysis time message
+  const getAnalysisMessage = (): string => {
+    if (!videoMetadata) return '오디오를 분석하고 있습니다.'
+    const minutes = Math.floor(videoMetadata.duration / 60)
+    return `${minutes}분의 음성을 분석하고 있습니다.`
+  }
+  
+  // Mount handling for SSR
+  useEffect(() => {
+    setIsMounted(true)
+  }, [])
+  
+  // Don't render if not mounted or not open
+  if (!isMounted || !isModalOpen) return null
+  
+  // Modal container styles
+  const containerClasses = cn(
+    'fixed bottom-6 right-6 z-[9999]',
+    'bg-gray-900 rounded-lg shadow-2xl',
+    'transition-all duration-300 ease-out',
+    'border border-gray-700',
+    isCollapsed ? 'w-80' : 'w-[480px]'
+  )
+  
+  const contentClasses = cn(
+    'p-6',
+    'transition-all duration-300',
+    isCollapsed && 'p-4'
+  )
+  
+  // Chevron rotation for collapse/expand
+  const chevronClasses = cn(
+    'transition-transform duration-200',
+    isCollapsed ? 'rotate-90' : '-rotate-90'
+  )
+  
+  // Status message based on current state
+  const getStatusMessage = () => {
+    if (error) return error
+    if (status === 'completed') return '분석이 완료되었습니다!'
+    if (status === 'failed') return '분석 중 오류가 발생했습니다.'
+    if (status === 'idle' || jobId?.startsWith('connecting_')) return '서버에 연결 중입니다...'
+    return '안녕하세요! 업체 저희를 응원하게 생각으로 애완 택시 사업하고 있어 별가족 사업 시간을 좋게 보냅니다.'
+  }
+  
+  // Get progress message
+  const getProgressMessage = () => {
+    if (status === 'completed') return '완료'
+    if (status === 'failed') return '실패'
+    return `${progress}%`
+  }
+  
+  const modalContent = (
+    <div className={containerClasses}>
+      <div className={contentClasses}>
+        {/* Header with collapse button */}
+        <div className="flex items-start justify-between mb-4">
+          <div className="flex-1">
+            {!isCollapsed && (
+              <>
+                <h3 className="text-lg font-semibold text-white mb-1">
+                  {getAnalysisMessage()}
+                </h3>
+                <p className="text-sm text-gray-400">
+                  {getStatusMessage()}
+                </p>
+              </>
+            )}
+          </div>
+          
+          <button
+            onClick={toggleCollapse}
+            className="ml-4 p-1.5 rounded hover:bg-gray-800 transition-colors"
+            aria-label={isCollapsed ? 'Expand' : 'Collapse'}
+          >
+            <ChevronRightIcon className={chevronClasses} size={20} />
+          </button>
+        </div>
+        
+        {/* Main content - hidden when collapsed */}
+        {!isCollapsed && (
+          <>
+            {/* Analysis time used */}
+            <div className="mb-4">
+              <p className="text-sm text-gray-300">
+                사용한 분석시간
+                <span className="ml-2 font-semibold text-white">
+                  {analysisTimeUsed}분
+                </span>
+              </p>
+            </div>
+            
+            {/* Video thumbnail and info */}
+            {videoMetadata && (
+              <div className="mb-4 bg-gray-800 rounded-lg p-3 flex items-center gap-3">
+                {/* Video thumbnail placeholder */}
+                  {videoMetadata.thumbnailUrl ? (
+                    <Image
+                      src={videoMetadata.thumbnailUrl}
+                      alt="Video thumbnail"
+                      width={80}
+                      height={56}
+                      className="w-full h-full object-cover rounded"
+                      style={{ width: '100%', height: '100%' }}
+                      unoptimized
+                    />
+                  ) : (
+                    <svg className="w-8 h-8 text-gray-500" fill="currentColor" viewBox="0 0 20 20">
+                      <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
+                      <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
+                    </svg>
+                  )}
+                {/* File info */}
+                <div className="flex-1">
+                  <p className="text-sm font-medium text-white truncate">
+                    {videoMetadata.fileName}
+                  </p>
+                  <p className="text-xs text-gray-400">
+                    {formatDuration(videoMetadata.duration)} • {(videoMetadata.fileSize / 1024 / 1024).toFixed(1)}MB
+                  </p>
+                </div>
+              </div>
+            )}
+            
+            {/* Info message */}
+            <div className="mb-4 flex items-start gap-2">
+              <svg className="w-5 h-5 text-blue-400 mt-0.5 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
+                <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
+              </svg>
+              <p className="text-xs text-gray-400">
+                항풍꿍꽁 바고 곳을 기조오로 클몇을 나눌 수 있어요.
+              </p>
+            </div>
+          </>
+        )}
+        
+        {/* Progress bar - always visible */}
+        <div className="flex items-center gap-3">
+          <div className="flex-1">
+            <ProgressBar
+              value={progress}
+              variant="over-background"
+              size="small"
+              valueLabel={getProgressMessage()}
+              className="w-full"
+            />
+          </div>
+          
+          {/* Close button when completed or failed */}
+          {(status === 'completed' || status === 'failed') && (
+            <button
+              onClick={closeModal}
+              className="px-3 py-1 text-sm bg-gray-800 hover:bg-gray-700 rounded transition-colors text-white"
+            >
+              닫기
+            </button>
+          )}
+        </div>
+      </div>
+    </div>
+  )
+  
+  return createPortal(modalContent, document.body)
+}
+
+export default TranscriptionProgressModal 
\ No newline at end of file
diff --git a/src/components/icons/index.tsx b/src/components/icons/index.tsx
index 6e38c2b..ed0715b 100644
--- a/src/components/icons/index.tsx
+++ b/src/components/icons/index.tsx
@@ -1,6 +1,7 @@
 import React from 'react'
 import {
   ChevronDown,
+  ChevronRight,
   Info,
   X,
   XCircle,
@@ -26,6 +27,12 @@ export const ChevronDownIcon: React.FC<IconProps> = ({
   size = 20,
 }) => <ChevronDown className={className} size={size} />
 
+// Chevron Right Icon (Collapse/Expand용)
+export const ChevronRightIcon: React.FC<IconProps> = ({
+  className,
+  size = 20,
+}) => <ChevronRight className={className} size={size} />
+
 // Info Icon (Help Text neutral용)
 export const InfoIcon: React.FC<IconProps> = ({ className, size = 20 }) => (
   <Info className={className} size={size} />
diff --git a/src/components/providers/TranscriptionProvider.tsx b/src/components/providers/TranscriptionProvider.tsx
new file mode 100644
index 0000000..9f00b73
--- /dev/null
+++ b/src/components/providers/TranscriptionProvider.tsx
@@ -0,0 +1,23 @@
+'use client'
+
+import React from 'react'
+import dynamic from 'next/dynamic'
+
+// Dynamically import the modal to avoid SSR issues
+const TranscriptionProgressModal = dynamic(
+  () => import('@/components/TranscriptionProgressModal'),
+  { ssr: false }
+)
+
+interface TranscriptionProviderProps {
+  children: React.ReactNode
+}
+
+export const TranscriptionProvider: React.FC<TranscriptionProviderProps> = ({ children }) => {
+  return (
+    <>
+      {children}
+      <TranscriptionProgressModal />
+    </>
+  )
+}
\ No newline at end of file
diff --git a/src/config/api.config.ts b/src/config/api.config.ts
index 7a9402f..ed11f31 100644
--- a/src/config/api.config.ts
+++ b/src/config/api.config.ts
@@ -5,7 +5,7 @@
 
 export const API_CONFIG = {
   // Feature flags
-  USE_MOCK_DATA: true, // Toggle between mock and real API
+  USE_MOCK_DATA: false, // Toggle between mock and real API
 
   // API Base URLs
   FASTAPI_BASE_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',
diff --git a/src/hooks/useTranscriptionPolling.ts b/src/hooks/useTranscriptionPolling.ts
new file mode 100644
index 0000000..60002ad
--- /dev/null
+++ b/src/hooks/useTranscriptionPolling.ts
@@ -0,0 +1,214 @@
+'use client'
+
+import { useEffect, useRef, useCallback } from 'react'
+import { useTranscriptionStore } from '@/lib/store/transcriptionStore'
+import { API_CONFIG } from '@/config/api.config'
+import { log } from '@/utils/logger'
+
+interface JobStatus {
+  status: 'queued' | 'started' | 'processing' | 'completed' | 'failed'
+  progress: number
+  current_message?: string
+  message?: string
+  error_message?: string
+  results?: Record<string, unknown>
+}
+
+export const useTranscriptionPolling = () => {
+  const {
+    jobId,
+    status,
+    updateProgress,
+    setError,
+    setEstimatedTime,
+    setResults,
+    onCompleteCallback,
+  } = useTranscriptionStore()
+  
+  const intervalRef = useRef<NodeJS.Timeout | null>(null)
+  const retryCountRef = useRef(0)
+  const currentIntervalRef = useRef(2000) // Start with 2 seconds
+  const isPageVisibleRef = useRef(typeof document !== 'undefined' ? !document.hidden : true)
+  
+  // Page visibility handling
+  useEffect(() => {
+    if (typeof document === 'undefined') return
+    
+    const handleVisibilityChange = () => {
+      isPageVisibleRef.current = !document.hidden
+    }
+    
+    document.addEventListener('visibilitychange', handleVisibilityChange)
+    return () => document.removeEventListener('visibilitychange', handleVisibilityChange)
+  }, [])
+  
+  // Adjust polling interval based on progress
+  const adjustInterval = useCallback((progress: number) => {
+    if (progress < 10) {
+      currentIntervalRef.current = 5000 // 5 seconds for initial stage
+    } else if (progress < 50) {
+      currentIntervalRef.current = 3000 // 3 seconds for middle stage
+    } else if (progress < 80) {
+      currentIntervalRef.current = 2000 // 2 seconds for later stage
+    } else {
+      currentIntervalRef.current = 1000 // 1 second for final stage
+    }
+    
+    // Increase interval if page is not visible
+    if (!isPageVisibleRef.current) {
+      currentIntervalRef.current *= 3
+    }
+  }, [])
+  
+  // Fetch job status from API
+  const fetchJobStatus = useCallback(async (jobId: string): Promise<JobStatus> => {
+    const statusUrl = `${API_CONFIG.FASTAPI_BASE_URL}/api/v1/ml/job-status/${jobId}`
+    console.log('Polling job status:', statusUrl)
+    
+    const response = await fetch(statusUrl, {
+      headers: {
+        // TODO: Add authorization header when auth is implemented
+        // 'Authorization': `Bearer ${token}`
+      }
+    })
+    
+    if (!response.ok) {
+      throw new Error(`Failed to fetch job status: ${response.statusText}`)
+    }
+    
+    return await response.json()
+  }, [])
+  
+  // Main polling function
+  const poll = useCallback(async () => {
+    if (!jobId || status === 'completed' || status === 'failed' || jobId.startsWith('connecting_')) {
+      return
+    }
+    
+    try {
+      const jobStatus = await fetchJobStatus(jobId)
+      
+      // Update progress (backend returns 0-100, not 0-1)
+      const progressPercentage = Math.round(jobStatus.progress)
+      updateProgress(progressPercentage)
+      
+      // Handle different statuses
+      switch (jobStatus.status) {
+        case 'completed':
+          updateProgress(100, 'completed')
+          if (intervalRef.current) {
+            clearInterval(intervalRef.current)
+            intervalRef.current = null
+          }
+          
+          // ✅ Handle results processing
+          log('useTranscriptionPolling', 'Transcription completed, processing results...')
+          
+          try {
+            if (jobStatus.results) {
+              // Store results in transcription store
+              setResults(jobStatus.results)
+              
+              // Process results if callback is set
+              if (onCompleteCallback) {
+                log('useTranscriptionPolling', 'Calling completion callback with results')
+                onCompleteCallback(jobStatus.results)
+              } else {
+                log('useTranscriptionPolling', 'No completion callback set, results stored in store')
+              }
+            } else {
+              log('useTranscriptionPolling', 'Warning: Completed status but no results found')
+              console.warn('Transcription completed but no results found in response')
+            }
+          } catch (error) {
+            log('useTranscriptionPolling', `Error processing results: ${error}`)
+            console.error('Error processing transcription results:', error)
+            setError('결과 처리 중 오류가 발생했습니다.')
+          }
+          break
+          
+        case 'failed':
+          setError(jobStatus.error_message || 'Transcription failed')
+          if (intervalRef.current) {
+            clearInterval(intervalRef.current)
+            intervalRef.current = null
+          }
+          break
+          
+        case 'processing':
+        case 'started':
+        case 'queued':
+          // Continue polling with adjusted interval
+          adjustInterval(progressPercentage)
+          retryCountRef.current = 0 // Reset retry count on success
+          break
+      }
+      
+      // Update estimated time if available
+      if (jobStatus.current_message) {
+        // Extract time from message if it contains time info
+        const timeMatch = jobStatus.current_message.match(/(\d+)\s*(seconds?|minutes?)/i)
+        if (timeMatch) {
+          const value = parseInt(timeMatch[1])
+          const unit = timeMatch[2].toLowerCase()
+          const seconds = unit.includes('minute') ? value * 60 : value
+          setEstimatedTime(seconds)
+        }
+      }
+      
+    } catch (error) {
+      console.error('Polling error:', error)
+      retryCountRef.current++
+      
+      // Stop polling after 3 retries
+      if (retryCountRef.current >= 3) {
+        setError('Failed to check transcription status. Please try again.')
+        if (intervalRef.current) {
+          clearInterval(intervalRef.current)
+          intervalRef.current = null
+        }
+      } else {
+        // Exponential backoff for retries
+        currentIntervalRef.current = Math.min(
+          currentIntervalRef.current * Math.pow(2, retryCountRef.current),
+          10000 // Max 10 seconds
+        )
+      }
+    }
+  }, [jobId, status, fetchJobStatus, updateProgress, setError, adjustInterval, setEstimatedTime, setResults, onCompleteCallback])
+  
+  // Start polling when jobId is set
+  useEffect(() => {
+    if (jobId && status === 'processing') {
+      // Initial poll immediately
+      poll()
+      
+      // Set up interval for subsequent polls
+      intervalRef.current = setInterval(() => {
+        poll()
+      }, currentIntervalRef.current)
+      
+      return () => {
+        if (intervalRef.current) {
+          clearInterval(intervalRef.current)
+          intervalRef.current = null
+        }
+      }
+    }
+  }, [jobId, status, poll])
+  
+  // Clean up on unmount
+  useEffect(() => {
+    return () => {
+      if (intervalRef.current) {
+        clearInterval(intervalRef.current)
+        intervalRef.current = null
+      }
+    }
+  }, [])
+  
+  return {
+    isPolling: !!intervalRef.current,
+    retryCount: retryCountRef.current,
+  }
+}
\ No newline at end of file
diff --git a/src/hooks/useUploadModal.ts b/src/hooks/useUploadModal.ts
index 4c02ceb..5d9595c 100644
--- a/src/hooks/useUploadModal.ts
+++ b/src/hooks/useUploadModal.ts
@@ -1,10 +1,11 @@
 'use client'
 
-import { useState } from 'react'
 import { useRouter } from 'next/navigation'
 import { mediaStorage } from '@/utils/storage/mediaStorage'
 import { projectInfoManager } from '@/utils/managers/ProjectInfoManager'
 import { log } from '@/utils/logger'
+import { useTranscriptionStore } from '@/lib/store/transcriptionStore'
+import { API_CONFIG } from '@/config/api.config'
 
 export interface TranscriptionData {
   files?: FileList
@@ -17,7 +18,7 @@ export interface TranscriptionData {
 
 export const useUploadModal = () => {
   const router = useRouter()
-  const [isTranscriptionLoading, setIsTranscriptionLoading] = useState(false)
+  const { startTranscription, setAnalysisTime } = useTranscriptionStore()
 
   const handleFileSelect = (files: FileList) => {
     if (process.env.NODE_ENV === 'development') {
@@ -41,27 +42,84 @@ export const useUploadModal = () => {
     const handleTranscriptionResponse = async (response: Response) => {
       if (response.ok) {
         const result = await response.json()
+        log('useUploadModal.ts', `Backend response: ${JSON.stringify(result)}`)
+        
         if (process.env.NODE_ENV === 'development') {
           console.log('Transcription started successfully: ', result)
         }
+        
+        // Update Progress Modal with real job ID from backend
+        if (result.job_id) {
+          // Update existing progress modal with real job ID
+          const { updateProgress } = useTranscriptionStore.getState()
+          useTranscriptionStore.setState({ jobId: result.job_id })
+          updateProgress(5, 'processing') // Start with 5% progress
+          
+          // Set analysis time from backend response (if available)
+          if (result.analysis_time_used) {
+            setAnalysisTime(result.analysis_time_used)
+          }
+          
+          log('useUploadModal.ts', `Started transcription with job_id: ${result.job_id}`)
+        } else {
+          log('useUploadModal.ts', 'Warning: Backend response missing job_id')
+        }
+        
         onSuccess?.()
         if (redirectToEditor) {
           router.push('/editor')
         }
       } else {
-        throw new Error(`HTTP error! status: ${response.status}`)
+        const errorText = await response.text()
+        log('useUploadModal.ts', `Backend error ${response.status}: ${errorText}`)
+        throw new Error(`Backend error ${response.status}: ${errorText}`)
       }
     }
+    
+    // Helper function to get video duration
+    const getVideoDuration = async (file: File): Promise<number> => {
+      return new Promise((resolve) => {
+        const video = document.createElement('video')
+        video.preload = 'metadata'
+        video.onloadedmetadata = () => {
+          window.URL.revokeObjectURL(video.src)
+          resolve(video.duration)
+        }
+        video.onerror = () => {
+          resolve(0) // Default to 0 if can't get duration
+        }
+        video.src = URL.createObjectURL(file)
+      })
+    }
 
     try {
-      setIsTranscriptionLoading(true)
       if (process.env.NODE_ENV === 'development') {
         console.log('Starting transcription with data:', data)
       }
 
+      // Show Progress Modal immediately with file info
+      if (data.method === 'file' && data.files && data.files.length > 0) {
+        const file = data.files[0]
+        const duration = await getVideoDuration(file)
+        
+        // Start with temporary job ID for immediate UI feedback
+        const tempJobId = `connecting_${Date.now()}`
+        startTranscription(tempJobId, {
+          fileName: file.name,
+          duration: duration,
+          fileSize: file.size,
+          thumbnailUrl: undefined,
+        })
+        
+        // Set mock analysis time initially
+        setAnalysisTime(74)
+      }
+
+
       let response: Response
       let projectId: string | null = null
       let mediaId: string | null = null
+      let fileKey: string | null = null
 
       if (data.method === 'file' && data.files) {
         // Generate project ID
@@ -72,62 +130,131 @@ export const useUploadModal = () => {
         log('useUploadModal.ts', `Saving video to IndexedDB: ${file.name}`)
 
         try {
-          // Extract video metadata
+          // Extract video metadata for project info only (don't save large file to IndexedDB)
+          log('useUploadModal.ts', 'Extracting video metadata...')
           const metadata = await projectInfoManager.extractVideoMetadata(file)
 
-          // Parse duration from string to number for MediaFile
+          // Parse duration from string to number
           const durationNum = metadata.duration
             ? parseFloat(metadata.duration.replace(/[^0-9.]/g, ''))
             : undefined
 
-          // Save to IndexedDB
-          mediaId = await mediaStorage.saveMedia(projectId, file, {
-            duration: durationNum,
-            videoSize: metadata.videoSize,
-          })
+          // Save only project metadata (not the video file itself)
+          log('useUploadModal.ts', 'Saving minimal project metadata...')
+          mediaId = 'media_' + Date.now()  // Generate simple ID without storing file
+          
+          // Store minimal project info in sessionStorage instead of IndexedDB
+          sessionStorage.setItem('currentProjectId', projectId)
+          sessionStorage.setItem('currentMediaId', mediaId)
+          sessionStorage.setItem('currentFileName', file.name)
+          sessionStorage.setItem('currentFileSize', file.size.toString())
+          sessionStorage.setItem('currentDuration', durationNum?.toString() || '0')
+          
+          log('useUploadModal.ts', `Project metadata saved with mediaId: ${mediaId}`)
+        } catch (error: unknown) {
+          console.error('Failed to extract video metadata:', error)
+          log('useUploadModal.ts', `Metadata Error: ${error}`)
+          
+          if (error instanceof Error) {
+            log('useUploadModal.ts', `Metadata Error Message: ${error.message}`)
+            log('useUploadModal.ts', `Metadata Error Stack: ${error.stack}`)
+          }
+          
+          // 메타데이터 추출 실패해도 API 호출은 계속 진행
+          log('useUploadModal.ts', 'Metadata extraction failed, but continuing with API calls...')
+          mediaId = 'media_fallback_' + Date.now()
+        }
+
+        log('useUploadModal.ts', 'Starting API calls...')
 
-          // Save project media info
-          await mediaStorage.saveProjectMedia({
-            projectId,
-            mediaId,
-            fileName: file.name,
-            fileType: file.type,
-            fileSize: file.size,
-            duration: metadata.duration
-              ? parseFloat(metadata.duration.replace(/[^0-9.]/g, ''))
-              : undefined,
-            metadata: {
-              videoSize: metadata.videoSize,
+        // Step 1: Generate presigned URL for S3 upload
+        try {
+          const generateUrlEndpoint = `${API_CONFIG.FASTAPI_BASE_URL}/api/upload-video/generate-url`
+          log('useUploadModal.ts', `Getting presigned URL from: ${generateUrlEndpoint}`)
+          
+          log('useUploadModal.ts', 'About to call fetch for presigned URL...')
+          const presignedResponse = await fetch(generateUrlEndpoint, {
+            method: 'POST',
+            headers: {
+              'Content-Type': 'application/json',
             },
+            body: JSON.stringify({
+              filename: file.name,
+              filetype: file.type || 'video/mp4'
+            })
           })
+          log('useUploadModal.ts', `Presigned URL response status: ${presignedResponse.status}`)
 
-          log('useUploadModal.ts', `Video saved with mediaId: ${mediaId}`)
-        } catch (error) {
-          console.error('Failed to save video to IndexedDB:', error)
-        }
+          if (!presignedResponse.ok) {
+            const errorText = await presignedResponse.text()
+            log('useUploadModal.ts', `Presigned URL error: ${errorText}`)
+            throw new Error(`Failed to get presigned URL: ${errorText}`)
+          }
 
-        // Create FormData for file upload
-        const formData = new FormData()
+          const presignedData = await presignedResponse.json()
+          log('useUploadModal.ts', `Presigned URL response: ${JSON.stringify(presignedData)}`)
+          
+          const { url: uploadUrl, fileKey: s3FileKey } = presignedData
+          fileKey = s3FileKey
+          log('useUploadModal.ts', `Got presigned URL, fileKey: ${fileKey}`)
 
-        // Add files to FormData
-        Array.from(data.files).forEach((file, index) => {
-          formData.append(`file_${index}`, file)
-        })
+          // Step 2: Upload file to S3
+          log('useUploadModal.ts', 'About to upload file to S3...')
+          const s3Response = await fetch(uploadUrl, {
+            method: 'PUT',
+            body: file,
+            headers: {
+              'Content-Type': file.type || 'video/mp4'
+            }
+          })
+          log('useUploadModal.ts', `S3 upload response status: ${s3Response.status}`)
 
-        // Add configuration
-        formData.append('language', data.language)
-        formData.append('useDictionary', data.useDictionary.toString())
-        formData.append('autoSubmit', data.autoSubmit.toString())
-        formData.append('method', data.method)
+          if (!s3Response.ok) {
+            const s3ErrorText = await s3Response.text()
+            log('useUploadModal.ts', `S3 upload error: ${s3ErrorText}`)
+            throw new Error(`Failed to upload to S3: ${s3Response.statusText}`)
+          }
+          log('useUploadModal.ts', 'File uploaded to S3 successfully')
+        } catch (s3Error: unknown) {
+          log('useUploadModal.ts', `Step 1-2 failed: ${s3Error}`)
+          console.error('Step 1-2 - Presigned URL or S3 Upload Error:', s3Error)
+          throw s3Error
+        }
 
-        // API endpoint for file upload transcription
-        response = await fetch('/api/transcription/upload', {
-          method: 'POST',
-          body: formData,
-        })
+        // Step 3: Request ML processing
+        try {
+          const processEndpoint = `${API_CONFIG.FASTAPI_BASE_URL}/api/v1/ml/process-video`
+          log('useUploadModal.ts', `Requesting ML processing: ${processEndpoint}`)
+          
+          const requestBody = {
+            video_path: fileKey,
+            enable_gpu: true,
+            emotion_detection: true,
+            language: data.language === 'Korean (South Korea)' ? 'ko' : 'auto',
+            max_workers: 4
+          }
+          log('useUploadModal.ts', `ML processing request body: ${JSON.stringify(requestBody)}`)
+          
+          log('useUploadModal.ts', 'About to call ML processing API...')
+          response = await fetch(processEndpoint, {
+            method: 'POST',
+            headers: {
+              'Content-Type': 'application/json',
+            },
+            body: JSON.stringify(requestBody)
+          })
+          log('useUploadModal.ts', `ML processing response status: ${response.status}`)
+        } catch (mlError: unknown) {
+          log('useUploadModal.ts', `Step 3 failed: ${mlError}`)
+          console.error('Step 3 - ML Processing Error:', mlError)
+          throw mlError
+        }
       } else if (data.method === 'link' && data.url) {
         // Send URL data as JSON
-        response = await fetch('/api/transcription/url', {
+        const urlUploadUrl = `${API_CONFIG.FASTAPI_BASE_URL}/api/transcription/url`
+        log('useUploadModal.ts', `Calling backend API for URL: ${urlUploadUrl}`)
+        
+        response = await fetch(urlUploadUrl, {
           method: 'POST',
           headers: {
             'Content-Type': 'application/json',
@@ -157,16 +284,36 @@ export const useUploadModal = () => {
       }
 
       await handleTranscriptionResponse(response)
-    } catch (error) {
+    } catch (error: unknown) {
       console.error('Error starting transcription:', error)
-      alert('Failed to start transcription. Please try again.')
-    } finally {
-      setIsTranscriptionLoading(false)
+      log('useUploadModal.ts', `Overall API Error: ${error}`)
+      log('useUploadModal.ts', `Error type: ${typeof error}`)
+      
+      if (error instanceof Error) {
+        log('useUploadModal.ts', `Error name: ${error.name}`)
+        log('useUploadModal.ts', `Error message: ${error.message}`)
+        log('useUploadModal.ts', `Error stack: ${error.stack}`)
+      }
+      
+      // Check for CORS error
+      let errorMessage = 'Failed to start transcription. Please try again.'
+      
+      if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
+        errorMessage = 'CORS 에러 또는 백엔드 서버 연결 실패. 백엔드 서버가 실행 중인지, CORS 설정이 올바른지 확인하세요.'
+        console.error('CORS/Network Error - 백엔드 .env 파일에 CORS_ORIGINS=http://localhost:3000 설정이 필요합니다.')
+      } else if (error instanceof Error) {
+        errorMessage = `API 연결 실패: ${error.message}`
+      }
+      
+      // Update store with error
+      const { setError } = useTranscriptionStore.getState()
+      setError(errorMessage)
+      
+      alert(errorMessage)
     }
   }
 
   return {
-    isTranscriptionLoading,
     handleFileSelect,
     handleStartTranscription,
   }
diff --git a/src/lib/store/transcriptionStore.ts b/src/lib/store/transcriptionStore.ts
new file mode 100644
index 0000000..3ab3879
--- /dev/null
+++ b/src/lib/store/transcriptionStore.ts
@@ -0,0 +1,152 @@
+'use client'
+
+import { create } from 'zustand'
+import { devtools, persist } from 'zustand/middleware'
+
+export interface VideoMetadata {
+  fileName: string
+  duration: number // in seconds
+  thumbnailUrl?: string
+  fileSize: number
+}
+
+export interface TranscriptionState {
+  // Job tracking
+  jobId: string | null
+  status: 'idle' | 'processing' | 'completed' | 'failed'
+  progress: number // 0-100
+  error: string | null
+  
+  // Video/file info
+  videoMetadata: VideoMetadata | null
+  
+  // Analysis info
+  analysisTimeUsed: number // in minutes
+  estimatedTotalTime: number | null // in seconds
+  
+  // Results handling
+  results: unknown | null // Store ML server results
+  onCompleteCallback: ((results: unknown) => void) | null
+  
+  // UI state
+  isModalOpen: boolean
+  isCollapsed: boolean
+  
+  // Actions
+  startTranscription: (jobId: string, metadata: VideoMetadata) => void
+  updateProgress: (progress: number, status?: TranscriptionState['status']) => void
+  setAnalysisTime: (minutes: number) => void
+  setEstimatedTime: (seconds: number) => void
+  setError: (error: string | null) => void
+  toggleCollapse: () => void
+  openModal: () => void
+  closeModal: () => void
+  reset: () => void
+  
+  // Results handling actions
+  setResults: (results: unknown) => void
+  onComplete: (callback: (results: unknown) => void) => void
+  clearResults: () => void
+}
+
+const initialState = {
+  jobId: null,
+  status: 'idle' as const,
+  progress: 0,
+  error: null,
+  videoMetadata: null,
+  analysisTimeUsed: 0,
+  estimatedTotalTime: null,
+  results: null,
+  onCompleteCallback: null,
+  isModalOpen: false,
+  isCollapsed: false,
+}
+
+export const useTranscriptionStore = create<TranscriptionState>()(
+  devtools(
+    persist(
+      (set) => ({
+        ...initialState,
+        
+        startTranscription: (jobId, metadata) => set((state) => ({
+          ...state,
+          jobId,
+          videoMetadata: metadata,
+          status: 'processing',
+          progress: 0,
+          error: null,
+          isModalOpen: true,
+          isCollapsed: false,
+        })),
+        
+        updateProgress: (progress, status) => set((state) => ({
+          ...state,
+          progress,
+          ...(status && { status }),
+        })),
+        
+        setAnalysisTime: (minutes) => set((state) => ({
+          ...state,
+          analysisTimeUsed: minutes,
+        })),
+        
+        setEstimatedTime: (seconds) => set((state) => ({
+          ...state,
+          estimatedTotalTime: seconds,
+        })),
+        
+        setError: (error) => set((state) => ({
+          ...state,
+          error,
+          status: error ? 'failed' : state.status,
+        })),
+        
+        toggleCollapse: () => set((state) => ({
+          ...state,
+          isCollapsed: !state.isCollapsed,
+        })),
+        
+        openModal: () => set((state) => ({
+          ...state,
+          isModalOpen: true,
+        })),
+        
+        closeModal: () => set((state) => ({
+          ...state,
+          isModalOpen: false,
+        })),
+        
+        reset: () => set(initialState),
+        
+        // Results handling actions
+        setResults: (results) => set((state) => ({
+          ...state,
+          results,
+        })),
+        
+        onComplete: (callback) => set((state) => ({
+          ...state,
+          onCompleteCallback: callback,
+        })),
+        
+        clearResults: () => set((state) => ({
+          ...state,
+          results: null,
+          onCompleteCallback: null,
+        })),
+      }),
+      {
+        name: 'transcription-storage',
+        partialize: (state) => ({
+          jobId: state.jobId,
+          status: state.status,
+          progress: state.progress,
+          videoMetadata: state.videoMetadata,
+          analysisTimeUsed: state.analysisTimeUsed,
+          // Note: results and callbacks are not persisted
+        }),
+      }
+    )
+  )
+)
\ No newline at end of file
diff --git a/src/utils/managers/AutosaveManager.ts b/src/utils/managers/AutosaveManager.ts
index dbe6af0..2ecc0f1 100644
--- a/src/utils/managers/AutosaveManager.ts
+++ b/src/utils/managers/AutosaveManager.ts
@@ -182,7 +182,7 @@ export class AutosaveManager {
     const startTime = Date.now()
 
     try {
-      // 로컬 저장 (항상)
+      // 로컬 저장 (IndexedDB 실패시 자동으로 fallback 사용)
       await projectStorage.saveProject(projectData)
       projectStorage.saveCurrentProject(projectData)
 
@@ -211,7 +211,19 @@ export class AutosaveManager {
         this.changeCounter = 0 // Reset counter after server save
       }
     } catch (err) {
-      logError('AutosaveManager.ts', 'Failed to save project', err)
+      // IndexedDB 관련 에러인지 확인하여 더 구체적인 로그 제공
+      let errorContext = 'Unknown error'
+      if (err instanceof Error) {
+        errorContext = err.message
+        if (err.message.includes('IndexedDB')) {
+          log(
+            'AutosaveManager.ts', 
+            'IndexedDB error detected - fallback storage should handle this automatically'
+          )
+        }
+      }
+      
+      logError('AutosaveManager.ts', `Failed to save project: ${errorContext}`, err)
       this.setSaveStatus('error')
 
       // 재시도 로직
diff --git a/src/utils/storage/indexedDBProjectStorage.ts b/src/utils/storage/indexedDBProjectStorage.ts
index a039d91..019049b 100644
--- a/src/utils/storage/indexedDBProjectStorage.ts
+++ b/src/utils/storage/indexedDBProjectStorage.ts
@@ -11,6 +11,7 @@ import {
 import { getTimestamp } from '@/utils/logger'
 
 const DB_NAME = 'ECGMediaStorage' // mediaStorage와 동일한 DB 사용
+const DB_VERSION = 3 // Match mediaStorage.ts version
 const PROJECTS_STORE = 'projects'
 const PROJECT_HISTORY_STORE = 'projectHistory'
 
@@ -24,28 +25,90 @@ export interface ProjectHistoryEntry {
 
 class IndexedDBProjectStorage implements ProjectStorage {
   private db: IDBDatabase | null = null
+  private initializationPromise: Promise<void> | null = null
+  private initializationAttempts = 0
+  private maxInitializationAttempts = 3
+  private isIndexedDBSupported = true
 
   /**
-   * IndexedDB 초기화 (mediaStorage와 동일한 DB 사용)
+   * IndexedDB 초기화 (에러 처리 및 재시도 로직 포함)
    */
   async initialize(): Promise<void> {
-    if (this.db) return // 이미 초기화됨
+    if (this.initializationPromise) {
+      return this.initializationPromise
+    }
+
+    if (!('indexedDB' in window)) {
+      console.warn(
+        `[${getTimestamp()}] indexedDBProjectStorage.ts IndexedDB not supported`
+      )
+      this.isIndexedDBSupported = false
+      return Promise.resolve()
+    }
 
+    this.initializationPromise = this.performInitialization()
+    return this.initializationPromise
+  }
+
+  private async performInitialization(): Promise<void> {
     return new Promise((resolve, reject) => {
-      const request = indexedDB.open(DB_NAME, 2) // Version 2 with new stores
+      this.initializationAttempts++
+      const request = indexedDB.open(DB_NAME, DB_VERSION)
+
+      const timeoutId = setTimeout(() => {
+        console.error(
+          `[${getTimestamp()}] indexedDBProjectStorage.ts IndexedDB initialization timeout (attempt ${this.initializationAttempts})`
+        )
+        reject(new Error('IndexedDB initialization timeout'))
+      }, 10000)
 
       request.onerror = () => {
+        clearTimeout(timeoutId)
+        const error = request.error?.message || 'Unknown IndexedDB error'
         console.error(
-          `[${getTimestamp()}] indexedDBProjectStorage.ts Failed to open IndexedDB`
+          `[${getTimestamp()}] indexedDBProjectStorage.ts Failed to open IndexedDB (attempt ${this.initializationAttempts}): ${error}`
         )
-        reject(new Error('Failed to open IndexedDB'))
+        
+        if (this.initializationAttempts < this.maxInitializationAttempts) {
+          console.log(
+            `[${getTimestamp()}] indexedDBProjectStorage.ts Retrying IndexedDB initialization...`
+          )
+          setTimeout(() => {
+            this.initializationPromise = null
+            this.performInitialization().then(resolve).catch(reject)
+          }, 2000)
+        } else {
+          this.isIndexedDBSupported = false
+          console.error(
+            `[${getTimestamp()}] indexedDBProjectStorage.ts IndexedDB failed after ${this.maxInitializationAttempts} attempts`
+          )
+          reject(new Error(`IndexedDB initialization failed after ${this.maxInitializationAttempts} attempts`))
+        }
       }
 
       request.onsuccess = () => {
+        clearTimeout(timeoutId)
         this.db = request.result
+        
+        this.db.onerror = (event) => {
+          console.error(
+            `[${getTimestamp()}] indexedDBProjectStorage.ts IndexedDB database error:`, event
+          )
+        }
+        
+        this.db.onversionchange = () => {
+          console.warn(
+            `[${getTimestamp()}] indexedDBProjectStorage.ts IndexedDB version change detected`
+          )
+          this.db?.close()
+          this.db = null
+          this.initializationPromise = null
+        }
+        
         console.log(
-          `[${getTimestamp()}] indexedDBProjectStorage.ts IndexedDB initialized successfully`
+          `[${getTimestamp()}] indexedDBProjectStorage.ts IndexedDB initialized successfully (attempt ${this.initializationAttempts})`
         )
+        this.initializationAttempts = 0
         resolve()
       }
 
@@ -79,10 +142,72 @@ class IndexedDBProjectStorage implements ProjectStorage {
   }
 
   /**
-   * 프로젝트 저장
+   * IndexedDB 지원 여부 확인
+   */
+  private isIndexedDBAvailable(): boolean {
+    return this.isIndexedDBSupported && this.db !== null
+  }
+
+  /**
+   * 폴백 저장 방식 (localStorage)
+   */
+  private async saveFallback(project: ProjectData): Promise<void> {
+    try {
+      const projects = this.getFallbackProjects()
+      const existingIndex = projects.findIndex(p => p.id === project.id)
+      
+      const updatedProject = { ...project, updatedAt: new Date() }
+      
+      if (existingIndex >= 0) {
+        projects[existingIndex] = updatedProject
+      } else {
+        projects.push(updatedProject)
+      }
+      
+      localStorage.setItem('ecg-projects-fallback', JSON.stringify(projects))
+      console.log(
+        `[${getTimestamp()}] indexedDBProjectStorage.ts Project "${project.name}" saved to fallback storage`
+      )
+    } catch (error) {
+      console.error(
+        `[${getTimestamp()}] indexedDBProjectStorage.ts Failed to save to fallback storage:`, error
+      )
+      throw error
+    }
+  }
+
+  /**
+   * 폴백 로드 방식
+   */
+  private getFallbackProjects(): ProjectData[] {
+    try {
+      const data = localStorage.getItem('ecg-projects-fallback')
+      return data ? JSON.parse(data) : []
+    } catch (error) {
+      console.error(
+        `[${getTimestamp()}] indexedDBProjectStorage.ts Failed to load fallback projects:`, error
+      )
+      return []
+    }
+  }
+
+  /**
+   * 프로젝트 저장 (폴백 지원)
    */
   async saveProject(project: ProjectData): Promise<void> {
-    if (!this.db) await this.initialize()
+    try {
+      if (!this.db && this.isIndexedDBSupported) {
+        await this.initialize()
+      }
+    } catch (error) {
+      console.warn(
+        `[${getTimestamp()}] indexedDBProjectStorage.ts IndexedDB initialization failed, using fallback`
+      )
+    }
+
+    if (!this.isIndexedDBAvailable()) {
+      return this.saveFallback(project)
+    }
 
     // 저장 시간 업데이트
     const updatedProject = {
@@ -91,22 +216,39 @@ class IndexedDBProjectStorage implements ProjectStorage {
     }
 
     return new Promise((resolve, reject) => {
-      const transaction = this.db!.transaction([PROJECTS_STORE], 'readwrite')
-      const store = transaction.objectStore(PROJECTS_STORE)
-      const request = store.put(updatedProject)
+      try {
+        const transaction = this.db!.transaction([PROJECTS_STORE], 'readwrite')
+        const store = transaction.objectStore(PROJECTS_STORE)
+        const request = store.put(updatedProject)
 
-      request.onsuccess = () => {
-        console.log(
-          `[${getTimestamp()}] indexedDBProjectStorage.ts Project "${project.name}" saved successfully`
-        )
-        resolve()
-      }
+        request.onsuccess = () => {
+          console.log(
+            `[${getTimestamp()}] indexedDBProjectStorage.ts Project "${project.name}" saved successfully`
+          )
+          resolve()
+        }
 
-      request.onerror = () => {
+        request.onerror = () => {
+          const error = request.error?.message || 'Unknown error'
+          console.error(
+            `[${getTimestamp()}] indexedDBProjectStorage.ts Failed to save project: ${error}`
+          )
+          // 에러 발생 시 폴백으로 재시도
+          this.saveFallback(project).then(resolve).catch(reject)
+        }
+
+        transaction.onerror = () => {
+          const error = transaction.error?.message || 'Transaction failed'
+          console.error(
+            `[${getTimestamp()}] indexedDBProjectStorage.ts Transaction error: ${error}`
+          )
+          this.saveFallback(project).then(resolve).catch(reject)
+        }
+      } catch (error) {
         console.error(
-          `[${getTimestamp()}] indexedDBProjectStorage.ts Failed to save project`
+          `[${getTimestamp()}] indexedDBProjectStorage.ts Exception while saving:`, error
         )
-        reject(new Error('프로젝트 저장에 실패했습니다.'))
+        this.saveFallback(project).then(resolve).catch(reject)
       }
     })
   }
diff --git a/src/utils/storage/mediaStorage.ts b/src/utils/storage/mediaStorage.ts
index 7db682a..6f4b468 100644
--- a/src/utils/storage/mediaStorage.ts
+++ b/src/utils/storage/mediaStorage.ts
@@ -5,7 +5,7 @@
 import { getTimestamp } from '@/utils/logger'
 
 const DB_NAME = 'ECGMediaStorage'
-const DB_VERSION = 2 // Version bump for new project stores
+const DB_VERSION = 3 // Version bump to fix missing stores
 const MEDIA_STORE = 'media'
 const PROJECT_MEDIA_STORE = 'projectMedia'
 // New project data stores
@@ -47,26 +47,94 @@ export interface ProjectMediaInfo {
 class MediaStorage {
   private db: IDBDatabase | null = null
   private blobUrls: Map<string, string> = new Map()
+  private initializationPromise: Promise<void> | null = null
+  private initializationAttempts = 0
+  private maxInitializationAttempts = 3
+  private isIndexedDBSupported = true
 
   /**
-   * IndexedDB 초기화
+   * IndexedDB 초기화 (에러 처리 및 재시도 로직 포함)
    */
   async initialize(): Promise<void> {
+    // 이미 초기화 중이라면 해당 Promise 반환
+    if (this.initializationPromise) {
+      return this.initializationPromise
+    }
+
+    // IndexedDB 지원 여부 확인
+    if (!('indexedDB' in window)) {
+      console.warn(
+        `[${getTimestamp()}] mediaStorage.ts IndexedDB not supported in this browser`
+      )
+      this.isIndexedDBSupported = false
+      return Promise.resolve()
+    }
+
+    this.initializationPromise = this.performInitialization()
+    return this.initializationPromise
+  }
+
+  private async performInitialization(): Promise<void> {
     return new Promise((resolve, reject) => {
+      this.initializationAttempts++
       const request = indexedDB.open(DB_NAME, DB_VERSION)
 
+      const timeoutId = setTimeout(() => {
+        console.error(
+          `[${getTimestamp()}] mediaStorage.ts IndexedDB initialization timeout (attempt ${this.initializationAttempts})`
+        )
+        reject(new Error('IndexedDB initialization timeout'))
+      }, 10000) // 10초 타임아웃
+
       request.onerror = () => {
+        clearTimeout(timeoutId)
+        const error = request.error?.message || 'Unknown IndexedDB error'
         console.error(
-          `[${getTimestamp()}] mediaStorage.ts Failed to open IndexedDB`
+          `[${getTimestamp()}] mediaStorage.ts Failed to open IndexedDB (attempt ${this.initializationAttempts}): ${error}`
         )
-        reject(new Error('Failed to open IndexedDB'))
+        
+        if (this.initializationAttempts < this.maxInitializationAttempts) {
+          console.log(
+            `[${getTimestamp()}] mediaStorage.ts Retrying IndexedDB initialization in 2 seconds...`
+          )
+          setTimeout(() => {
+            this.initializationPromise = null
+            this.performInitialization().then(resolve).catch(reject)
+          }, 2000)
+        } else {
+          this.isIndexedDBSupported = false
+          console.error(
+            `[${getTimestamp()}] mediaStorage.ts IndexedDB initialization failed after ${this.maxInitializationAttempts} attempts. Falling back to memory storage.`
+          )
+          reject(new Error(`IndexedDB initialization failed after ${this.maxInitializationAttempts} attempts`))
+        }
       }
 
       request.onsuccess = () => {
+        clearTimeout(timeoutId)
         this.db = request.result
+        
+        // 데이터베이스 에러 핸들러 등록
+        this.db.onerror = (event) => {
+          console.error(
+            `[${getTimestamp()}] mediaStorage.ts IndexedDB database error:`, event
+          )
+        }
+        
+        // 버전 변경 처리
+        this.db.onversionchange = () => {
+          console.warn(
+            `[${getTimestamp()}] mediaStorage.ts IndexedDB version change detected. Closing connection.`
+          )
+          this.db?.close()
+          this.db = null
+          this.initializationPromise = null
+        }
+        
         console.log(
-          `[${getTimestamp()}] mediaStorage.ts IndexedDB initialized successfully`
+          `[${getTimestamp()}] mediaStorage.ts IndexedDB initialized successfully (attempt ${this.initializationAttempts})`
         )
+        this.initializationAttempts = 0 // Reset attempts on success
         resolve()
       }
 
@@ -116,14 +184,34 @@ class MediaStorage {
   }
 
   /**
-   * 비디오 파일 저장
+   * IndexedDB 지원 여부 확인
+   */
+  private isIndexedDBAvailable(): boolean {
+    return this.isIndexedDBSupported && this.db !== null
+  }
+
+  /**
+   * 비디오 파일 저장 (폴백 지원)
    */
   async saveMedia(
     projectId: string,
     file: File,
     metadata?: Partial<MediaFile>
   ): Promise<string> {
-    if (!this.db) await this.initialize()
+    try {
+      if (!this.db && this.isIndexedDBSupported) {
+        await this.initialize()
+      }
+    } catch (error) {
+      console.warn(
+        `[${getTimestamp()}] mediaStorage.ts IndexedDB initialization failed, using fallback storage`
+      )
+    }
+
+    // IndexedDB가 사용 불가능한 경우 폴백 방식
+    if (!this.isIndexedDBAvailable()) {
+      return this.saveFallback(projectId, file, metadata)
+    }
 
     const mediaId = `media_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`
 
@@ -140,56 +228,176 @@ class MediaStorage {
     }
 
     return new Promise((resolve, reject) => {
-      const transaction = this.db!.transaction([MEDIA_STORE], 'readwrite')
-      const store = transaction.objectStore(MEDIA_STORE)
-      const request = store.add(mediaFile)
+      try {
+        const transaction = this.db!.transaction([MEDIA_STORE], 'readwrite')
+        const store = transaction.objectStore(MEDIA_STORE)
+        const request = store.add(mediaFile)
 
-      request.onsuccess = () => {
-        console.log(
-          `[${getTimestamp()}] mediaStorage.ts Media saved: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`
-        )
-        resolve(mediaId)
-      }
+        request.onsuccess = () => {
+          console.log(
+            `[${getTimestamp()}] mediaStorage.ts Media saved: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`
+          )
+          resolve(mediaId)
+        }
 
-      request.onerror = () => {
+        request.onerror = () => {
+          const error = request.error?.message || 'Unknown error'
+          console.error(
+            `[${getTimestamp()}] mediaStorage.ts Failed to save media: ${error}`
+          )
+          reject(new Error(`Failed to save media: ${error}`))
+        }
+
+        transaction.onerror = () => {
+          const error = transaction.error?.message || 'Transaction failed'
+          console.error(
+            `[${getTimestamp()}] mediaStorage.ts Transaction error while saving media: ${error}`
+          )
+          reject(new Error(`Transaction error: ${error}`))
+        }
+      } catch (error) {
         console.error(
-          `[${getTimestamp()}] mediaStorage.ts Failed to save media`
+          `[${getTimestamp()}] mediaStorage.ts Exception while saving media:`, error
         )
-        reject(new Error('Failed to save media'))
+        reject(error)
       }
     })
   }
 
   /**
-   * 비디오 파일 로드
+   * 폴백 저장 방식 (sessionStorage + Blob URL)
+   */
+  private async saveFallback(
+    projectId: string,
+    file: File,
+    metadata?: Partial<MediaFile>
+  ): Promise<string> {
+    const mediaId = `fallback_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`
+    
+    try {
+      // Blob URL 생성 및 캐싱
+      const blobUrl = URL.createObjectURL(file)
+      this.blobUrls.set(mediaId, blobUrl)
+      
+      // 메타데이터만 sessionStorage에 저장
+      const mediaInfo = {
+        id: mediaId,
+        projectId,
+        fileName: file.name,
+        fileType: file.type,
+        fileSize: file.size,
+        createdAt: new Date().toISOString(),
+        lastAccessed: new Date().toISOString(),
+        ...metadata,
+      }
+      
+      sessionStorage.setItem(`media_${mediaId}`, JSON.stringify(mediaInfo))
+      
+      console.log(
+        `[${getTimestamp()}] mediaStorage.ts Media saved to fallback storage: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`
+      )
+      
+      return mediaId
+    } catch (error) {
+      console.error(
+        `[${getTimestamp()}] mediaStorage.ts Failed to save media to fallback storage:`, error
+      )
+      throw error
+    }
+  }
+
+  /**
+   * 폴백 로드 방식
+   */
+  private async loadFallback(mediaId: string): Promise<MediaFile | null> {
+    try {
+      const mediaInfoStr = sessionStorage.getItem(`media_${mediaId}`)
+      if (!mediaInfoStr) return null
+      
+      const mediaInfo = JSON.parse(mediaInfoStr)
+      
+      // Blob URL이 이미 있는 경우
+      if (this.blobUrls.has(mediaId)) {
+        return {
+          ...mediaInfo,
+          blob: null, // 실제 Blob은 Blob URL로 대체
+          createdAt: new Date(mediaInfo.createdAt),
+          lastAccessed: new Date(mediaInfo.lastAccessed),
+        }
+      }
+      
+      return null
+    } catch (error) {
+      console.error(
+        `[${getTimestamp()}] mediaStorage.ts Failed to load media from fallback storage:`, error
+      )
+      return null
+    }
+  }
+
+  /**
+   * 비디오 파일 로드 (폴백 지원)
    */
   async loadMedia(mediaId: string): Promise<MediaFile | null> {
-    if (!this.db) await this.initialize()
+    try {
+      if (!this.db && this.isIndexedDBSupported) {
+        await this.initialize()
+      }
+    } catch (error) {
+      console.warn(
+        `[${getTimestamp()}] mediaStorage.ts IndexedDB initialization failed, using fallback storage`
+      )
+    }
+
+    // IndexedDB가 사용 불가능한 경우 폴백 방식
+    if (!this.isIndexedDBAvailable()) {
+      return this.loadFallback(mediaId)
+    }
 
     return new Promise((resolve, reject) => {
-      const transaction = this.db!.transaction([MEDIA_STORE], 'readonly')
-      const store = transaction.objectStore(MEDIA_STORE)
-      const request = store.get(mediaId)
+      try {
+        const transaction = this.db!.transaction([MEDIA_STORE], 'readonly')
+        const store = transaction.objectStore(MEDIA_STORE)
+        const request = store.get(mediaId)
+
+        request.onsuccess = () => {
+          const media = request.result
+          if (media) {
+            // Update last accessed time (fire and forget)
+            this.updateLastAccessed(mediaId).catch((error) => {
+              console.warn(
+                `[${getTimestamp()}] mediaStorage.ts Failed to update last accessed time:`, error
+              )
+            })
+            console.log(
+              `[${getTimestamp()}] mediaStorage.ts Media loaded: ${media.fileName}`
+            )
+            resolve(media)
+          } else {
+            resolve(null)
+          }
+        }
 
-      request.onsuccess = () => {
-        const media = request.result
-        if (media) {
-          // Update last accessed time
-          this.updateLastAccessed(mediaId)
-          console.log(
-            `[${getTimestamp()}] mediaStorage.ts Media loaded: ${media.fileName}`
+        request.onerror = () => {
+          const error = request.error?.message || 'Unknown error'
+          console.error(
+            `[${getTimestamp()}] mediaStorage.ts Failed to load media: ${error}`
           )
-          resolve(media)
-        } else {
-          resolve(null)
+          reject(new Error(`Failed to load media: ${error}`))
         }
-      }
 
-      request.onerror = () => {
+        transaction.onerror = () => {
+          const error = transaction.error?.message || 'Transaction failed'
+          console.error(
+            `[${getTimestamp()}] mediaStorage.ts Transaction error while loading media: ${error}`
+          )
+          reject(new Error(`Transaction error: ${error}`))
+        }
+      } catch (error) {
         console.error(
-          `[${getTimestamp()}] mediaStorage.ts Failed to load media`
+          `[${getTimestamp()}] mediaStorage.ts Exception while loading media:`, error
         )
-        reject(new Error('Failed to load media'))
+        reject(error)
       }
     })
   }
diff --git a/src/utils/transcription/segmentConverter.ts b/src/utils/transcription/segmentConverter.ts
index 4de521c..b671c8c 100644
--- a/src/utils/transcription/segmentConverter.ts
+++ b/src/utils/transcription/segmentConverter.ts
@@ -1,7 +1,26 @@
 import { ClipItem, Word } from '@/app/(route)/editor/types'
 
-// real.json segment 타입 정의
-interface Segment {
+// ML Server result segment 타입 정의
+interface MLServerSegment {
+  start_time: number
+  end_time: number
+  speaker: {
+    speaker_id: string
+    confidence?: number
+  }
+  text: string
+  words: Array<{
+    word: string
+    start: number
+    end: number
+    confidence?: number
+    volume_db?: number  // Audio level for animations
+    pitch_hz?: number   // Pitch frequency for animations
+  }>
+}
+
+// Legacy real.json segment 타입 정의 (호환성 유지)
+interface LegacySegment {
   start_time: number
   end_time: number
   duration: number
@@ -22,6 +41,9 @@ interface Segment {
   }>
 }
 
+// 통합 Segment 타입 (두 형식 모두 지원)
+type Segment = MLServerSegment | LegacySegment
+
 export interface Metadata {
   filename: string
   duration: number
@@ -59,7 +81,7 @@ export function convertSegmentToClip(
 ): ClipItem {
   const clipId = `clip_${index + 1}_${Date.now()}`
 
-  // words 변환 - ensure text is properly preserved
+  // words 변환 - ensure text is properly preserved and include audio metadata
   const words: Word[] = segment.words.map((word, wordIndex) => ({
     id: `${clipId}_word_${wordIndex}`,
     text: word.word.trim(), // Trim any whitespace
@@ -67,18 +89,26 @@ export function convertSegmentToClip(
     end: word.end,
     isEditable: true,
     confidence: word.confidence,
+    // Include audio metadata for animations (ML server format)
+    volume_db: 'volume_db' in word ? word.volume_db : undefined,
+    pitch_hz: 'pitch_hz' in word ? word.pitch_hz : undefined,
   }))
 
   // Ensure text is properly decoded and preserved
   const text = segment.text || words.map((w) => w.text).join(' ')
 
+  // Calculate duration - handle both ML server and legacy formats
+  const duration = 'duration' in segment 
+    ? segment.duration 
+    : (segment.end_time - segment.start_time)
+
   return {
     id: clipId,
     timeline: formatTime(segment.start_time),
     speaker: segment.speaker.speaker_id, // Keep original speaker ID for now
     subtitle: text,
     fullText: text,
-    duration: `${segment.duration.toFixed(1)}초`,
+    duration: `${duration.toFixed(1)}초`,
     thumbnail: '/placeholder-thumb.jpg',
     words,
   }
@@ -89,11 +119,41 @@ export function convertSegmentsToClips(segments: Segment[]): ClipItem[] {
   return segments.map((segment, index) => convertSegmentToClip(segment, index))
 }
 
-// real.json 전체 데이터 구조
+// ML Server 결과 데이터 구조
+export interface MLServerResult {
+  job_id: string
+  status: string
+  progress: number
+  result: {
+    metadata: {
+      filename: string
+      duration: number
+      total_segments: number
+      unique_speakers: number
+    }
+    segments: MLServerSegment[]
+  }
+}
+
+// Legacy real.json 전체 데이터 구조
 export interface TranscriptionData {
   metadata?: Metadata
   speakers?: Record<string, undefined>
-  segments: Segment[]
+  segments: LegacySegment[]
+}
+
+// ML Server segments만 추출하는 헬퍼 함수
+export function extractSegmentsFromMLResult(result: MLServerResult): MLServerSegment[] {
+  return result.result.segments
+}
+
+// 화자 목록 추출 함수
+export function extractSpeakersFromSegments(segments: (MLServerSegment | LegacySegment)[]): string[] {
+  const speakerSet = new Set<string>()
+  segments.forEach(segment => {
+    speakerSet.add(segment.speaker.speaker_id)
+  })
+  return Array.from(speakerSet).sort()
 }
 
 // real.json 데이터를 파싱하고 clips로 변환
```
